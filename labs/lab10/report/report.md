---
## Front matter
title: "Лабораторная работа №10"
author: "Ханина Людмила Константиновна"

## Generic otions
lang: ru-RU

## Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

## Pdf output format
toc: true # Table of contents
toc-depth: 2
lof: true # List of figures
lot: true # List of tables
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n polyglossia
polyglossia-lang:
  name: russian
  options:
	- spelling=modern
	- babelshorthands=true
polyglossia-otherlangs:
  name: english
## I18n babel
babel-lang: russian
## Fonts
mainfont: PT Serif
romanfont: PT Serif
sansfont: PT Sans
monofont: PT Mono
mainfontoptions: Ligatures=TeX
romanfontoptions: Ligatures=TeX
sansfontoptions: Ligatures=TeX,Scale=MatchLowercase
monofontoptions: Scale=MatchLowercase,Scale=0.9
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
## Pandoc-crossref LaTeX customization
figureTitle: "Рис."
tableTitle: "Таблица"
listingTitle: "Листинг"
lofTitle: "Список иллюстраций"
lotTitle: "Список таблиц"
lolTitle: "Листинги"
## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---

# Цель работы

Изучить основы программирования в оболочке ОС UNIX/Linux. Научиться писать небольшие командные файлы.

# Задание

* Написать скрипт, который при запуске будет делать резервную копию самого себя (то есть файла, в котором содержится его исходный код) в другую директорию backup в вашем домашнем каталоге. При этом файл должен архивироваться одним из архиваторов на выбор zip, bzip2 или tar. Способ использования команд архивации необходимо узнать, изучив справку.
* Написать пример командного файла, обрабатывающего любое произвольное число аргументов командной строки, в том числе превышающее десять. Например, скрипт может последовательно распечатывать значения всех переданных аргументов.
* Написать командный файл — аналог команды ls (без использования самой этой команды и команды dir). Требуется, чтобы он выдавал информацию о нужном каталоге и выводил информацию о возможностях доступа к файлам этого каталога.
* Написать командный файл, который получает в качестве аргумента командно йстроки формат файла (.txt, .doc, .jpg, .pdf и т.д.) и вычисляет количество таких файлов в указанной директории. Путь к директории также передаётся в виде аргумента командной строки.

# Выполнение лабораторной работы

1. C помощью команды man узнаем информацию про zip, bzip2, tar. 

![zip](image/zip.png){ #fig:001 width=70% }

![bzip2](image/bzip2.png){ #fig:001 width=70% }

![tar](image/tar.png){ #fig:001 width=70% }

2. Создаем файл lab01first.sh, в котором будем писать скрипт, который при запуске будет делать резервную копию самого себя в другую директорию backup в нашем домашнем каталоге. Файл будет архивироваться с помощью архиватора bzip2. Перед запуском изменим права доступа, чтобы иметь возможность запускать скрипт. 

![Первый скрипт](image/1.1.png){ #fig:001 width=70% }

3. Посмотрим корректность исполнения скрипта. Для этого зайдем в появившийся каталог backup и посмотрим текст архивированного файла. Все хорошо. 

![Запускаем первый скрипт](image/1.2.png){ #fig:001 width=70% }

![Содержание архивированного файла](image/1.3.png){ #fig:001 width=70% }

4. Далее создаем файл lab10second, в котором будет второй скрипт, обрабатывающий любое произвольное число аргументов командной строки, в том числе превышающее десять. Например, скрипт может последовательно распечатывать значения всех переданных аргументов. Сразу изменим права доступа. 

![Второй скрипт](image/2.1.png){ #fig:001 width=70% }

5. Запустим скрипт и убедимся, что он исправно работает. 

![Запускаем второй скрипт](image/2.2.png){ #fig:001 width=70% }

6. Далее создаем файл lab10third, в котором будет третий скрипт, аналог команды ls (без использования самой этой команды и команды dir). Требуется, чтобы он выдавал информацию о нужном каталоге и выводил информацию о возможностях доступа к файлам этого каталога. Также изменим права доступа, чтобы суметь запустить скрипт. 

![Третий скрипт](image/3.1.png){ #fig:001 width=70% }

7. Запустим скрипт и убедимся, что он исправно работает. 

![Запускаем третий скрипт](image/3.2.png){ #fig:001 width=70% }

8. Далее создаем файл lab10fourth, в котором будет четвертый скрипт, который получает в качестве аргумента командной строки формат файла (.txt, .doc, .jpg, .pdf и т.д.) и вычисляет количество таких файлов в указанной директории. Путь к директории также передаётся в виде аргумента командной строки. Также изменим права доступа, чтобы суметь запустить скрипт. 

![Четвертый скрипт](image/4.1.png){ #fig:001 width=70% }

9. Запустим скрипт и убедимся, что он исправно работает. 

![Запускаем четвертый скрипт](image/4.2.png){ #fig:001 width=70% }

# Контрольные вопросы

1. Командный процессор (командная оболочка, интерпретатор команд shell) − это программа, позволяющая пользователю взаимодействовать с операционной системой компьютера. В Linux доступны следующие командные оболочки:
* Bash — самая распространённая оболочка под Linux. Она ведёт историю команд и предоставляет возможность их редактирования;
* pdksh — клон korn shell, хорошо известной оболочки в системах UNIX;
* tcsh — улучшенная версия >C shell;
* zsh — новейшая из перечисленных здесь оболочек; реализует улучшенное дополнение и другие удобные функции. 

2. POSIX (англ. Portable Operating System Interface — переносимый интерфейс операционных систем) — набор стандартов, описывающих интерфейсы между операционной системой и прикладной программой (системный API), библиотеку языка C и набор приложений и их интерфейсов. Стандарт создан для обеспечения совместимости различных UNIX-подобных операционных систем и переносимости прикладных программ на уровне исходного кода, но может быть использован и для не-Unix систем.

3. Командный процессор bash обеспечивает возможность использования переменных типа строка символов. Имена переменных могут быть выбраны пользователем. Пользователь имеет возможность присвоить переменной значение некоторой строки символов. Для создания массива используется команда set с флагом -A. За флагом следует имя переменной, а затем список значений, разделённых пробелами.

4. Команда let является показателем того, что последующие аргументы представляют собой выражение, подлежащее вычислению. Команда read позволяет читать значения переменных со стандартного ввода.

5. В bash можно применять арифметические операции: сложение (+), вычитание (-), умножение (*), целочисленное деление (/) и целочисленный остаток от деления (%). 

6. В (( )) можно записывать условия оболочки bash. 

7. Стандартные имена переменныx: PATH, HOME, IFS, MAIL, TERM, LOGNAME.

8. Метасимволы – это специальные символы, имеющие особое значение, такие как подстановочный символ, символ повторения, символ несовпадения или диапазон символов.

9. Экранирование может быть осуществлено с помощью предшествующего метасимволу символа, который является метасимволом. Для экранирования группы метасимволов нужно заключить её в одинарные кавычки. Строка, заключённая в двойные кавычки, экранирует все метасимволы, кроме $, ’ , , ”. 

10. Последовательность команд может быть помещена в текстовый файл. Такой файл называется командным. Далее этот файл можно выполнить по команде:
```
bash командный_файл [аргументы]
```
Чтобы не вводить каждый раз последовательности символов bash, необходимо изменить код защиты этого командного файла, обеспечив доступ к этому файлу по выполнению. Это может быть сделано с помощью команды:
```
chmod +x имя_файла
```

11. Группу команд можно объединить в функцию. Для этого существует ключевое слово function, после которого следует имя функции и список команд, заключённых в фигурные скобки.

12. Чтобы выяснить, является ли файл каталогом или обычным файлом, можно воспользоваться командой
```test -f [путь до файла]
```
для проверки, является ли обычным файлом и
```test -d [путь до файла]
```
для проверки, является ли он каталогом. 

13. 
* Команду set используют для вывода списка переменных окружения.
* Команду unset используют для удаления переменной из вашего окружения командной оболочки.
* Команда typeset является встроенной и предназначена для наложения ограничений на переменные.

14. При вызове командного файла на выполнение параметры ему могут быть переданы точно таким же образом, как и выполняемой программе. В командный файл можно передать до девяти параметров. При использовании где-либо в командном файле комбинации символов $i, где 0 < 𝑖 < 10, вместо неё будет осуществлена подстановка значения параметра с порядковым номером i, т.е. аргумента командного файла с порядковым номером i. Использование комбинации символов $0 приводит к подстановке вместо неё имени данного командного файла.

15. Специальные переменные языка bash и их назначение:
* $0 — в этом переменной лежит путь и имя скрипта, который запустил пользователь;
* $# — количество параметров, переданных скрипту из командной строки;
* $? — код возврата (exit code, result code), с которым завершилась предыдущая команда;
* $! — номер процесса, в рамках которого выполняется последняя вызванная на выполнение в командном режиме команда;
* $$ - номер процесса, в котором выполняется данный скрипт. 

# Выводы

Я научилась писать небольшие командный файлы для решения различных вопрсов. 
