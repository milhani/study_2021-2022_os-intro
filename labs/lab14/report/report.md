---
## Front matter
title: "Лабораторная работа №14"
author: "Ханина Людмила Константиновна"

## Generic otions
lang: ru-RU

## Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

## Pdf output format
toc: true # Table of contents
toc-depth: 2
lof: true # List of figures
lot: true # List of tables
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n polyglossia
polyglossia-lang:
  name: russian
  options:
	- spelling=modern
	- babelshorthands=true
polyglossia-otherlangs:
  name: english
## I18n babel
babel-lang: russian
## Fonts
mainfont: PT Serif
romanfont: PT Serif
sansfont: PT Sans
monofont: PT Mono
mainfontoptions: Ligatures=TeX
romanfontoptions: Ligatures=TeX
sansfontoptions: Ligatures=TeX,Scale=MatchLowercase
monofontoptions: Scale=MatchLowercase,Scale=0.9
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
## Pandoc-crossref LaTeX customization
figureTitle: "Рис."
tableTitle: "Таблица"
listingTitle: "Листинг"
lofTitle: "Список иллюстраций"
lotTitle: "Список таблиц"
lolTitle: "Листинги"
## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---

# Цель работы

Приобретение практических навыков работы с именованными каналами.

# Задание

Изучите приведённые в тексте программы server.c и client.c. Взяв данные примеры за образец, напишите аналогичные программы, внеся следующие изменения:
* Работает не 1 клиент, а несколько (например, два).
* Клиенты передают текущее время с некоторой периодичностью (например, раз в пять
секунд). Используйте функцию sleep() для приостановки работы клиента.
* Сервер работает не бесконечно, а прекращает работу через некоторое время (например, 30 сек). Используйте функцию clock() для определения времени работы сервера.
Что будет в случае, если сервер завершит работу, не закрыв канал?

# Выполнение лабораторной работы

1. Создадим файлы с помощью команды
```
touch common.h server.c client.c Makefile
```

2. Вставим в них предложенные коды, но добавим некоторые вещи. Например, в файл common.h добавим заголовочные файлы unistd.h и time.h, которые пригодятся для других скриптов.

![common.h](image/common.png){ #fig:001 width=70% }

3. В server.c добавим цикл while, чтобы отслеживать время работы сервера. Разница между текущим временем time(NULL) и началом (begin) должна быть не больше 30 секунд. 

![server.c](image/server.png){ #fig:001 width=70% }

4. В client.c добавим цикл, отвечающий за сообщения о текущем времени, и команду sleep(5), которая будет приостанавлиать работу клиента на 5 секунд.  

![client.c](image/client.png){ #fig:001 width=70% }

5. Makefile менять не будем. 

![Makefile](image/Makefile.png){ #fig:001 width=70% }

6. Компилируем коды с помощью команды make all. 

![make all](image/make.png){ #fig:001 width=70% }

7. Проверим работу скриптов. Запустим в одном терминале ./server, а в нескольких других ./client. Спустя 30 секунд сервер прекратить работу. Скрипт работает корректно. 

![Работа server.c](image/1.1.png){ #fig:001 width=70% }

![Другие терминалы](image/1.2.png){ #fig:001 width=70% }

8. Если сервер завершит работу, не закрыв канал, то при повторном запуске сервера появится ошибка: 

![Ошибка](image/3.png){ #fig:001 width=70% }

# Контрольные вопросы

1. Именованные каналы, в отличие от неименованных, могут использоваться неродственными процессами. Они дают вам, по сути, те же возможности, что и неименованные каналы, но с некоторыми преимуществами, присущими обычным файлам. Именованные каналы используют специальную запись в директории для управления правами доступа.

2. Чтобы создать неименованный канал из командной строки, нужно использовать символ |. 

3. Чтобы создать именованный канал, используется команда mkfifo либо команда mknod с типом файла p

4. Неименованный канал создается вызовом pipe, который заносит в массив int [2] два дескриптора открытых файлов. fd[0] – открыт на чтение, fd[1] – на запись (вспомните STDIN == 0, STDOUT == 1). Канал уничтожается, когда будут закрыты все файловые дескрипторы ссылающиеся на него.

5. Именованный канал FIFO доступен как объект в файловой системе. При этом, до открытия объекта FIFO на чтение, собственно коммуникационного объекта не создаётся. После открытия открытия объекта FIFO в одном процессе на чтение, а в другом на запись, возникает ситуация полностью эквивалентная использованию неименованного канала.

Объект FIFO в файловой системе создаётся вызовом функции int mkfifo(const char *pathname, mode_t mode);  

6. Если прочитать меньшее число байтов, то вернется требуемое число байтов, остаток сохраняется для последующих чтений. Если прочитать большее число байтов, чем находится в канале или FIFO, то вернется доступное число байтов.

7. Запись числа байтов, меньшего емкости канала или FIFO, гарантированно атомарно. Если записать число байтов большее, чем это позволяет канал или FIFO, вызов write(2) блокируется до освобождения требуемого места. При этом атомарность операции не гарантируется.

8. Да, могут. Количество процессов, которые могут параллельно присоединяться к любому концу канала, не ограничено. 

9. Функция write() переписывает count байт из буфера, на который указывает bufy в файл, соответствующий дескриптору файла handle. Указателю положения в файле дается приращение на количество записанных байт. Если файл открыт в текстовом режиме, то символы перевода строки автоматически дополняются символами возврата каретки. Тем не менее _rtl_write() не производит таких дополнений. Возвращаемым значением является количество действительно записанных байт. Если встретится ошибка, это количество может быть меньше, чем count. В случае ошибки возвращается — 1. Единица в вызове функции write в server.c означает идентификатор стандартного потока вывода.

10. Интерпретирует номер ошибки, передаваемый в функцию в качестве аргумента — errornum, в понятное для человека текстовое сообщение (строку). Откуда берутся эти ошибки? Ошибки эти возникают при вызове функций стандартных Си-библиотек. То есть хорошим тоном программирования будет — использование этой функции в паре с другой, и если возникнет ошибка, то пользователь или программист поймет как исправить ошибку, прочитав сообщение функции strerror.

# Выводы

Я научилась работать с именованными каналами и изменять скрипты так, чтобы они выполняли определенные вещи. 
